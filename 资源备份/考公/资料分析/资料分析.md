# 资料分析

# 实用速算技巧：

## ==**加/减法**==采用尾数法、高位叠加法

### **尾数法**：

- 将最后一位或最后两位相加，根据选项得出对应的答案（必须为==**精确计算**==，如果单位亿这种就是四舍五入得来的，不能使用尾数法）：

![](https://pub-5622690a70e94eb09c339b579d7ed3e0.r2.dev/PicGo/20250403175911539.png)



### 高位叠加法：





## ==乘法==技巧：小分互换法、拆分法 

#### 小分互换法：![](https://pub-5622690a70e94eb09c339b579d7ed3e0.r2.dev/PicGo/20250408111823898.png)

（如果是多位小数或多位大数的情况，则取前面2或3个最高位进行大概计算，获取一个区间）

#### 拆分法：

![](https://pub-5622690a70e94eb09c339b579d7ed3e0.r2.dev/PicGo/20250408114905637.png)

如果是多位小数或多位大数的情况，则取前面2或3个最高位进行大概计算，获取一个区间。要有==动态思维==，前面如果是往小取值，后面拆分时就要动态的往大一点取值

![](https://pub-5622690a70e94eb09c339b579d7ed3e0.r2.dev/PicGo/20250408154231063.png)



## ==除法==技巧：拆分法、直除法

### 拆分法：

![](https://pub-5622690a70e94eb09c339b579d7ed3e0.r2.dev/PicGo/20250408163924663.png)

### 直除法：

1.关于基期+增量

2.与比重有关

3.和平均数、倍数、比值

![](https://pub-5622690a70e94eb09c339b579d7ed3e0.r2.dev/PicGo/20250410141453049.png)



例题：根据分母，对分子进行构造，完成对分子的拆分从而快速得出范围![](https://pub-5622690a70e94eb09c339b579d7ed3e0.r2.dev/PicGo/20250410143031580.png)





## 关于基期、增长量、增长率和现期计算

### 给定增长率：

#### 415份数法：

![](https://pub-5622690a70e94eb09c339b579d7ed3e0.r2.dev/PicGo/20250410145238004.png)

415份数法：是一种比例的思想（）

如果给定增长率，计算对应的基期、变化量和现期



```
1.将增长率换算为分数
2.分母是几，则将去年的基值设为几份。想象ABX的比例关系
3.利用实际量求出对应的一份
```

![](https://pub-5622690a70e94eb09c339b579d7ed3e0.r2.dev/PicGo/20250410172123166.png)

#### 假设分析法：







言语理解

资料分析

数量关系

常识

申论





```
熟悉 Java，熟悉 Stream 流、Lambda 表达式、集合等。
熟悉 SSH 、SSM + Spring Boot 开发框架，熟悉 Spring 的 AOP、IOC编程思想
熟悉 MySQL 及库表设计，能熟练编写 SQL 完成统计分析等功能，有自定义索引的性能优化实践经历
熟悉 MyBatis、MyBatis Plus，能使用 MyBatis X 自动生成 CRUD 代码
熟悉缓存设计，能够运用 Redis 实现缓存，并通过分布式锁解决缓存击穿问题
掌握 Git、Maven、IDEA、Swagger、浏览器控制台等工具，并能通过 CodeGeex 等 AI 编程助手提高开发效率。
了解 Nacos 、Dubbo、Spring Cloud Gateway 等微服务技术。能用 Gateway 实现鉴权、转发、流量染色、参数校验和访问信息统计。
```

```
自学和对问题理解能力较强，能熟练阅读文档自学，例如对象存储文档 、组件库、ChatGLM 开放平台等，并可以快速编写 Demo。问题解决能力较强，能够利用 GitHub Issues 区、AI 工具、搜索引擎、Stack Overflow 等自主解决问题
```

 基于 Spring Boot、Dubbo、Spring Cloud Gateway 的 API 开放平台。
 管理员可以发布并管理所有接口、统计各接口调用信息。使用者可以开通接口并在线调用进行测试，在其项目中只需引入SDK包并配置 对应的AK / SK密钥后即可调用接口










```

```



```

```



```
sz14547557@gmail.com
sz14547557@googlemail.com
```

```sql
from ZXProject p where exists (select m from p.members m where m.personId=:personId) and p.authorizeDate>=:startDate and p.authorizeDate<=:endDate and p.checkStatus=:checkStatus
```

```
https://www.google.com.hk/url?sa=p&hl=zh-CN&pref=hkredirect&pval=yes&q=https://www.google.com.hk/search%3Fq%3D%25E5%25BE%25B7%25E5%259B%25BD%25E5%25A6%2582%25E6%259E%259C%25E4%25B8%258D%25E5%258F%2591%25E5%258A%25A8%25E4%25BA%258C%25E6%2588%2598%25E4%25BC%259A%25E6%2580%258E%25E6%25A0%25B7&ust=1745918549458526&usg=AOvVaw3n12NGG7m_tAQ8O1DiodGr
```

```

```



```
ALL_CHARGE_PRO_ID
```

使用门面模式和注册器模式。前端不需要指定后端的调用接口类型，隐藏对应调用的内部接口，对请求进行统一处理



```
门面模式：对子系统进行统一管理，扩展一个门面系统
注册器模式：实现解耦，方便扩展
迭代器模式
```

Java推荐使用那种方式创建多线程？

> ```java
>   CompletableFuture<Void> voidCompletableFuture1= CompletableFuture.runAsync(() -> {
>             for (int i = 0; i < 100; i++) {
>                 System.out.println("我是线程1" + i);
>             }
>         });
> ```
>
> 

##### Java使用 CompletableFuture方式创建多线程时如何指定多个异步任务之间的执行顺序？

> 使用 上一个异步任务. thenAccept、thenApply、thenCompose 方法
>
> ```
>   CompletableFuture<Void> voidCompletableFuture1= CompletableFuture.runAsync(() -> {
>             for (int i = 0; i < 100; i++) {
>                 System.out.println("我是线程1" + i);
>             }
>         });
> 
>         // 指定异步顺序，不带返回值
>         // CompletableFuture<Void> voidCompletableFuture2 = voidCompletableFuture1.thenAccept(state -> {
>         //     for (int i = 0; i < 100; i++) {
>         //         System.out.println("我是线程2" + i);
>         //     }
>         // });
>         // 指定异步顺序，带返回值
>         CompletableFuture<String> voidCompletableFuture2 = voidCompletableFuture1.thenApply(state -> {
>             for (int i = 0; i < 100; i++) {
>                 System.out.println("我是线程2" + i);
>             }
>             return "我是返回值";
>         });
>         // 使用thenCompose串行执行异步任务，可以将前一个任务的结果传递给后一个任务
>         CompletableFuture<String> composeFuture = voidCompletableFuture2.thenCompose(result -> CompletableFuture.supplyAsync(() -> {
>             System.out.println("我是thenCompose中的线程，获取到上一个任务的结果: " + result);
>             return "thenCompose的返回值";
>         }));
> 
>         // CompletableFuture<Void> voidCompletableFuture2=   CompletableFuture.runAsync(() -> {
>         //     for (int i = 0; i < 100; i++) {
>         //         System.out.println("我是线程2" + i);
>         //     }
>         // });
> 
>         // 组装异步结果，保证异步处理完毕
>         CompletableFuture.allOf(voidCompletableFuture1, voidCompletableFuture2).join();
>         System.out.println("我是异步处理完毕");
> 
>         try {
>          	// 使用get可以手动获取异步方法的返回值
>             String s = voidCompletableFuture2.get();
>             System.out.println(s);
>         } catch (InterruptedException e) {
>             throw new RuntimeException(e);
>         } catch (ExecutionException e) {
>             throw new RuntimeException(e);
>         }
> ```
>
> 

##### Java使用 CompletableFuture方式创建多线程时如何自定义线程池？

> ```
>     private static final ExecutorService executorService = Executors.newFixedThreadPool(10);
> 
> ```
>
> 



```
四川大学科研管理信息系统
驾驶舱项目
聚合搜索API项目
```

